// enchant.js本体やクラスをエクスポートする
enchant();


const canvas = {
	width: 320,
	height: 320
}

const player_s = {
	w: 48,
	h: 48
}

const hana = {
	sx : 0,
	sy : 96,
	sw : 126,
	sh : 64,
	dx : 64,
	dy : 64,
	dw : 126,
	dh : 64
}

const coin_s = {
	w:32,
	h:32,
}

// bettyのsrcを指定
const betty = './img/betty.png'
// flowersのsrcを指定
const flowers = './img/flowers.png'
// マップで使用するタイルセット画像を設定する
const map1 = './img/map1.png'
// コインイメージのsrcを指定
const piece = './img/piece.png'

// one_0のsrcを指定
const one_0 = './sound/one_0.mp3'
// Readyのsrcを指定
const Ready = './sound/Ready.wav'

// コインを作るクラス
var Coin = enchant.Class.create(enchant.Sprite, {
	initialize: function(x, y, w, h) {
		enchant.Sprite.call(this,w,h);
		this.x = x;
		this.y = y;
		this.image = core.assets[piece];
		this.tick = 0;
		// アニメーションパターン
		this.anime = [8,9,10,11];
		// アニメーション表示をする処理
		this.addEventListener(Event.ENTER_FRAME, function(e) {
			if(this.tick <= 8) {
				this.frame = this.tick
			} else {
				this.frame = this.anime[this.tick%4];
			}
			this.tick++;
		});
	}
});

// プリイヤーキャラクターを作成するクラス
// 「Sprite」クラウを継承
var Player = enchant.Class.create(enchant.Sprite, {
	initialize: function(x,y,w,h,map) {
		// 「Sprite」クラスのコンストラクタをコール

		// var player = new Sprte(48, 48)が「enchant.Sprite.call(this,48,48)」に置き換わる
		enchant.Sprite.call(this, w, h);


		// プロパティのメソッドを参照するときに使用したオブジェクト名(player)が、「this」キーワードになっている
		// スプライトで表示する画像を設定
		this.image = core.assets[betty];
		// 表示するフレームの番号を設定する。
		this.frame = 3;
		// 表示位置のx座標を設定する
		this.x = x;
		// 表示位置のy座標を設定する
		this.y  = y;
		// フレーム数をカウントするプロパティを追加
		this.tick = 0;
		// プレイヤーのHP(ヒットポイント)を格納するプロパティを追加する
		this.hp = 1000;

		// キー入力を検出するには、「Core」オブジェクトの「input」プロパティを使います。
		// enchant.jsのサポートする入力は、「左」「右」「上」「下」「a」「b」ボタン６つです。
		// それぞれのボタンにプロパティとキーは以下の通りです。
		// core.input.left : 左キー押下で反応
		// core.input.right : 右キー押下で反応
		// core.input.up : 上キー押下で反応
		// core.input.down : 下キー押下で反応
		// core.input.a : 指定した特定のキーを押下で反応
		// core.input.b : 指定した特定のキーを押下で反応
		this.addEventListener(Event.ENTER_FRAME, function(e) {
			// スプライトをアニメーション表示する際のフレームの切り替え順番は、画像により異なります。
			// ここで使用しているキャラクターの画像で歩行アニメーションを表示するには、次の順番でフレームを切り替える必要があります。
			// 左：1,5,9,13
			// 右：3,7,11,15
			// 上：2,6,10,14
			// 下：0,4,8,12
			// 順番の通り切り替えるには、まず、フレーム数をカウントする「tick」プロパティを追加します。
			// このプロパティは、移動操作を行った際にフレーム数をカウントします。なお、「tick」プロパティは独自に定義したプロパティで
			// ゲーム自体のフレーム数(「core.frame」プロパティ)とは異なるので注意してください。

			// 左ボタンが押されたら、スプライトをx方向に「-4」ピクセル移動
			if(core.input.left) {
				// もしマップ内にある時
				if(this.x > -30) {
					this.x -=4;
					// マップ上に当たり判定がある場合は移動しない
					if(map.hitTest(this.x + 16, this.y + 40))this.x += 4;
					// スプライトのフレーム番号を切り替えてアニメーションを表示する
					this.frame = this.tick%4*4+1
					// フレーム数をインクリメントする
					this.tick ++;
				}
			}

			// 右ボタンが押されたら、スプライトをy方向に「4」ピクセル移動
			if(core.input.right) {
				if(this.x< canvas.width+20) {
					this.x += 4;
					if(map.hitTest(this.x + 24, this.y + 40))this.x -= 4;
					this.frame = this.tick%4*4+3
					this.tick ++;
				}
			}

			// 上ボタンが押されたら、スプライトをy方向に「-4」ピクセル移動
			if(core.input.up) {
				if(this.y > 0) {
					this.y -= 4
					if(map.hitTest(this.x + 24, this.y + 40))this.y += 4;
					this.frame = this.tick%4*4+2
					this.tick ++;
				}
			}

			// 下ボタンが押されたら、スプライトをy方向に「4」ピクセル移動
			if(core.input.down) {
				if(this.y + player_s.h < canvas.height) {
					this.y += 4
					if(map.hitTest(this.x + 24, this.y + 40))this.y -= 4;
					this.frame = this.tick%4*4
					this.tick ++;
				}
			}
		});

		// 「touchmove」イベントが発生したときに実行するリスナを登録する
		// このタッチイベントはキャラクタに付いてるのでマップをドラッグしてもなにも起こらない
		this.addEventListener(Event.TOUCH_MOVE,function(e) {
			// イベントリスナを登録するには、「EventTarget」オブジェクトの「addEventListener」メソッドを使います。
			// 引数には、イベントタイプとリスナ(イベント発生時に実行する関数)を指定します。
			// ここでは、スプライトの「TOUCH_MOVE」イベントに対するリストを登録しています。
			// イベントの種類に対しては http://wise9.github.io/enchant.js/doc/core/ja/symbols/enchant.Event.htmlを参考にする


			// スプライトをタッチして移動した場合、またはドラッグした場合に移動する。
			this.x = e.x - this.width/2;
			this.y = e.y - this.height/2;
		});
	}
});

window.onload = function(){

	//ゲームオブジェクトを作成
	core = new Core(320, 320);

	//fps(1秒あたりの画面の描画回数)を設定(省略時は「30」)
	core.fps = 16;

	// スコアを保持するプロパティ追加
	core.score = 0;

	// ゲームで使用する画像ファイルをプリロードするには「Core」オブジェクトの「preload」メソッド
	// (「core.preload」)を使います。引数には、画像ファイルのパスを指定します。
	// 複数の場合には、「,」で区切って列挙します。
	// ゲームで使用する画像ファイルと音ファイルを指定
	core.preload(betty, map1, flowers, one_0, Ready, piece);

	// サウンドを再生するには、まず、「Sound」オブジェクトを「load」メソッドでサウンドファイルを
	// 読み込みます。引数には「mp3」形式、「wab」形式のサウンドファイルのパスとMIME Type(省略可)を指定します。

	// BGM用のサウンドファイルを読み込み
	core.bgm = Sound.load(one_0);
	// SE用のサウンドファイルを読み込み
	core.se = Sound.load(Ready);

	// ファイルのプリロードが完了したときに実行される関数
	core.onload = function() {
		// スプライトを作成するには、まず「Sprite」コンストラクタでオブジェクトを生成します。
		// 引数には、スプライトの幅と高さを指定します。次に「image」プロパティに表示する画像を「Core」
		// オブジェクトの「assets」プロパティ(「core.assets」プロパティ)で取得して設定します。
		// スプライトの画像は、指定した高さと幅の「フレーム」という領域で分割されます。どのフレーム
		// を表示するかは「frame」プロパティに番号(インデックス)で指定します。フレームの番号は
		// 左上から右下に「0」から順に数えます。
		// 例えば、サンプルでは192X192ピクセルの画像(betty.png)を48X48の領域で分割しているので
		// フレーム番号は次のようになります。
		// [0][1][2][3]
		// [4][5][6][7]
		// [8][9][10][11]
		// [12][13][14][15]
		// ＊各番号はスプライトのフレーム番号に相応します！

		// ラベルを作成する
		var infoLabel = new Label('enchant.js サンプル')

		// 画像の任意の範囲を切り取って、新しい画像を作成するには、「Surface」オブジェクト(以下、サーフィス)を使います。

		// 再生する前にボリュームを設定します。
		// BGMのボリュームを設定する(0~1)
		core.bgm.volume = 0.5;

		// サーフィスを作成するには、まず、「Surface」コンストラクタでオブジェクトを生成します。引数には、幅と高さを指定します。
		// サーフィスを作成する
		var image = new Surface(canvas.width, canvas.height);

		// 次に、「draw」メソッド引数で指定した画像「サーフィス」を描画します。「draw」メソッドの引数の指定方法には、次の四つがあります。
		// image.draw(image) : imageをサーフィスの(0,0)の位置に描画する
		// image.draw(image, dx, dy) : imageをサーフィスの(dx, dy)の位置に描画する
		// image.draw(image, dx, dy, dw, dh) : imageをサーフィスの(dx, dy)の位置に幅(dw)ピクセル、高さ(dh)ピクセルで描画する
		// image.draw(image, sw, sy, sw, sh, dx, dy, dw, dh) : imageの(sx,sy)の位置から幅(sw),高さ(sh)ピクセルの領域を、サーフィスの(dx, dy)の位置に幅dw,高さdwピクセルで描画します。
		// 「flowers.png」の(0,96)の位置から幅「126」ピクセル、高さ「64」ピクセルの領域を
		// サーフィスの(64, 64)の位置に幅「126」ピクセル、高さ「64」ピクセルで描画する
		image.draw(core.assets[flowers], hana.sx, hana.sy, hana.sw, hana.sh, hana.dx, hana.dy, hana.dw, hana.dh)

		// サーフィスを表示するためのスプライト（背景）を作成します。
		var bg = new Sprite(canvas.width, canvas.height)
		// スプライトにサーフィスを設定する
		bg.image = image;

		// マップを作成する
	    var map = new Map(16, 16);
	    // マップで使用するタイルセット画像を設定する
	    map.image = core.assets[map1];

	    // マップデータ(タイルの並びを表す2次元配列)
	    map.loadData([
	      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,83,84,84,84,84,84,84,84,84,84,84,84],
	      [1,1,1,1,1,1,1,1,99,100,116,116,116,116,116,116,116,116,116,116],
	      [1,1,1,1,1,16,17,18,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,32,33,34,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,48,49,50,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,20,20,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,16,18,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,48,50,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,1,1,1,1,1],
	      [1,1,1,1,1,1,1,1,99,101,1,1,1,1,1,1,1,1,1,1]
	    ],
	    [
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,28,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,28,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,28,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,28,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,28,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,23,23,23,23,23,23,-1,-1,-1],
	      [-1,23,23,23,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,28,-1,-1,-1],
	      [-1,-1,-1,-1,23,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,28,-1,-1,-1,-1,-1,-1,-1,-1,28,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,28,-1],
	      [-1,28,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
	      [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
	    ]);
	    // マップの当たり判定データ(タイルが当たり判定を持つかを表す2次元配列)
	    map.collisionData = [
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0],
	      [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	    ]

		// スプライトで表示する画像を設定する

		// スプライトを作成する
		// frame : 表示するフレームの番号
		// image : 表示する画像
		// rotation : 回転角度
		// scaleX : x方向の倍率
		// scaleY : y方向の倍率
		// x : x座標
		// y : y座標

		infoLabel.x = 16;
		// 表示位置のx座標を設定する
		infoLabel.y = 0;
		// 表示位置のy座標を設定する
		infoLabel.color = '#00f';
		// 文字色を設定する
		infoLabel.font = '14px sens-serif';
		// フォントサイズとフォントの種類を設定する

		bg.addEventListener(Event.TOUCH_END,function(e) {
			// 「Sound」オブジェクトのプロパティとメソッドは、次の通りです。
			// pause() : 再生を中断する
			// play() : 再生を開始する
			// stop() : 再生を停止する

			// BGMを再生する
			// core.bgm.play();

			// currentTime : 現在再生位置(秒)
			// duration : 再生時間（秒）。mp3は取得不可
			// volume : 音量。0(無音)~1(最大)

			// SEを再生する
			// core.se.play();
		});

		bg.addEventListener(Event.ENTER_FRAME, function(e) {
			// BGMをループさせる
			if(core.bgm.currentTime >= core.bgm.duration-0.1) {
				core.bgm.currentTime = 0;
			}
		});

		// スプライトを実際の画面上に表示するには、表示オブジェクトツリーにスプライトを追加しなければなりません。
		// ここでは、ルートシーンにスプライトを追加します。
		// ルートシーンにスプライトを追加するには「Core」オブジェクトの「rootScene」プロパティでルートシーンを参照し、
		// 「addChild」メソッドを実行します。「addChild」メソッドの引数は、スプライトを指定します。

		// rootSceneにマップを追加する
	    core.rootScene.addChild(map);


		// ルートシーンにスプライトを追加
		core.rootScene.addChild(bg);

		var player = new Player(120,50,player_s.w,player_s.h,map);
		//rootSceneにスプライトを追加します。
		core.rootScene.addChild(player);

		// rootSceneにラベルを追加する
		core.rootScene.addChild(infoLabel);

		// rootsceneで「enterframe」イベントが発生した時に実行されるリスナ
		core.rootScene.addEventListener(Event.ENTER_FRAME, function(e) {
			if (player.x > canvas.width) {
				player.x = 280;
				core.pushScene(core.field(player.x, player.y));
				// popした時のためにx座標を少し戻しておく
			}
		});
	}

	// 画面を別の画面に切り替えるには、「Scene」オブジェクト(以下、シーン)を使います。
	// 新しいシーンに２つ目のマップ画面を作成して２つのマップ画面を切り替えられるようにするには、「game.js」を以下のようにシーンを追加します。
	// 新しいシーンを作成する関数
	core.field = function(px, py) {

		// 新しいシーンを作成する
		var scene = new Scene()

		// マップを生成する
		var map = new Map(16,16);

		map.image = core.assets[map1];

		map.loadData([
			[37,37,37,37,37,37,37,37,37,19,19,19,32,33,33,33,33,33,33,33],
			[37,37,37,37,37,37,37,37,37,20,20,20,48,49,49,49,49,49,49,49],
			[37,37,23,23,23,23,23,23,23,23,7,37,37,37,37,37,37,37,37,37],
			[84,84,84,84,84,84,84,84,84,84,7,37,37,37,37,37,37,37,37,37],
			[116,116,116,116,116,116,116,116,100,100,7,37,37,20,37,37,37,37,37,37],
			[37,37,23,23,23,23,23,7,100,100,7,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,7,100,100,7,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,7,100,100,7,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,7,100,100,7,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,7,100,100,23,23,23,23,23,23,23,23,37,37],
			[37,37,37,37,37,37,37,7,100,100,84,84,84,84,84,84,84,84,84,84],
			[37,37,37,23,23,23,23,23,100,100,116,116,116,116,116,116,116,116,116,116],
			[37,37,37,37,37,37,37,37,100,100,37,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,37,100,100,37,37,37,37,37,37,37,37,37,37],
			[37,37,23,23,23,23,23,7,100,100,37,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,7,100,100,37,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,7,100,100,37,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,7,100,100,37,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,23,100,100,37,37,37,37,37,37,37,37,37,37],
			[37,37,37,37,37,37,37,37,100,100,37,37,37,37,37,37,37,37,37,37]
		]);
		map.collisionData = [
			[0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
			[0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
			[0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],
			[0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0],
			[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
		];
	// シーンにマップを追加する
	scene.addChild(map);

	var coins= [];
	for (var i=0;i < 10; i++) {
		let coin = new Coin(128,80+16*i,coin_s.w,coin_s.h);
		scene.addChild(coin);
		coins[i] = coin;
	}
	// プレイヤーキャラを作成する
	var player = new Player(0, py, player_s.w, player_s.h, map);
	// シーンにプレイヤーのスプライトを追加する
	scene.addChild(player);

	scene.addEventListener(Event.ENTER_FRAME, function(e){
		// プレイやのx座標が「1」以下なら、前のシーンに切り替える
		if(player.x < -20) {
			core.popScene();
		}
		// プレイヤーキャラとコインの当たり判定
		for(var i in coins) {
			if(player.within(coins[i],coin_s.w/2)) {
				// コインを取ったスコアを加算して更新
				core.score = scoreLabel.score += 100;
				// 取ったコインを削除する
				scene.removeChild(coins[i]);
				delete coins[i];
			}
		}
	});

	// スコアをフォントで表示するラベルを作成

	// スコアの表示と加算する処理は、２つ目のマップ（シーン）で行なっています。このため、最初にマップに戻った時に、
	// スコアラベルが削除されるので、スコアを保持できません。そこで「Core」オブジェことの「score」プロパティに、スコアラベルの「score」
	// プロパティの値を代入して、スコアを保持するようにしています。このように、ゲーム全体で保持しておきたい値は、「Core」オブジェクトのプロパティに
	// 保存しておくのがポイントです。

	// スコアラベルのプロパティ
	// easing : イージングの間隔、「0」でイージングなし
	// label : ラベル文字列（既定は[SCORE:]）
	// score : 点数
	// 引数はラベル表示位置のxy座標
	var scoreLabel = new ScoreLabel(16, 0);
	// 初期値設定
	scoreLabel.score = core.score;
	// シーンにラベルを追加する
	scene.addChild(scoreLabel)

	return scene; // シーンを返す
}
	// ゲームをスタート
	core.start();
}